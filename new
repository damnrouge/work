Technique Summary in Linear Steps
The technique combines direct system calls, API unhooking, and shellcode Reflective DLL Injection (sRDI) to create a memory dump of the LSASS process (for credential extraction via tools like Mimikatz) while bypassing AV/EDR monitoring. It avoids disk writes and user-mode API hooks. Below is a step-by-step linear breakdown of the process, based on the PoC tool "Dumpert" integrated with Cobalt Strike.

Gather OS Version Information: Use the Native API RtlGetVersion to retrieve the Windows OS version and build number. This determines the correct system call numbers (e.g., from online tables like j00ru's syscall tables), as they vary across OS versions.
Map System Call Numbers to Assembly Functions: Create OS-specific assembly functions (using MASM in Visual Studio) that directly invoke syscalls. Reference Native API functions (e.g., NtOpenProcess becomes ZwOpenProcess) to these assembly stubs, allowing direct syscall execution without calling hooked user-mode APIs like those in ntdll.dll.
Unhook Monitored APIs: Restore potentially hooked Native APIs (e.g., in ntdll.dll) by overwriting the first 5 bytes (typically a JMP hook) with original instructions, including the syscall number. Use direct syscall versions of APIs like ZwProtectVirtualMemory and ZwWriteVirtualMemory to change memory protections and write the restored bytes without triggering hooks in the call stack.
Open LSASS Process Handle: Use the direct syscall equivalent of NtOpenProcess to obtain a handle to the LSASS process with necessary access rights (e.g., PROCESS_ALL_ACCESS).
Create LSASS Minidump: Invoke direct syscalls for memory reading and file writing (e.g., equivalents of MiniDumpWriteDump or custom memory dump logic) to generate a minidump of LSASS memory. Write it to a temporary file on disk (in the PoC) or handle it in memory.
Convert to sRDI Shellcode (for Diskless Execution): Compile the Dumpert logic into a DLL. Use the sRDI ConvertToShellcode.py script to transform the DLL into position-independent shellcode. This shellcode includes a reflective loader that maps the DLL into memory with proper permissions (no massive RWX regions).
Inject Shellcode via Cobalt Strike: Use Cobalt Strike's shinject command (via an Aggressor script) to inject the sRDI shellcode into the current process (avoiding remote thread creation like CreateRemoteThread). The script waits for the dump to complete, then downloads the minidump file from the target.
Extract Credentials Offline: Transfer the minidump to a safe host and use Mimikatz (e.g., sekurlsa::minidump) to extract credentials, hashes, or Kerberos tickets without running Mimikatz on the target.

Notes on Why It Evades EDR

Bypasses User-Mode Hooks: EDR/AV products hook user-mode APIs (e.g., in Win32 or Native APIs like ntdll.dll) to monitor suspicious calls (e.g., process opening or memory dumping). Direct syscalls skip these APIs entirely, executing privileged operations via assembly instructions (syscall) that transition directly to kernel-mode, avoiding the hooked entry points in user-mode.
Handles Hooked Call Stacks: Even unhooking uses direct syscalls (e.g., for memory protection changes), preventing recursion into monitored APIs. This evades "inception"-like scenarios where unhooking tools themselves trigger hooks deeper in the stack.
OS-Version Awareness: By dynamically mapping syscalls based on OS build, the technique adapts to variations, reducing static signatures that EDR might detect in hardcoded tools.
Memory-Only Injection with sRDI: Avoids disk writes (no executables dropped), which EDR often scans for. sRDI uses position-independent code with proper permissions (e.g., RX instead of RWX), optional PE header cleaning, and no reflective-aware DLL requirement, minimizing memory artifacts that behavioral EDR rules target (e.g., large suspicious allocations or remote threads).
Kernel-Level Challenges for Detection: Malicious activity occurs in kernel-mode (via syscalls), where EDR can't easily hook due to PatchGuard protections. EDR would need kernel drivers for monitoring, but this is risky and limited, making syscall-based evasion hard to block without false positives.
Overall Stealth: Combines techniques to mimic legitimate behavior (e.g., no obvious API patterns like Mimikatz's), focuses on in-memory operations, and uses tools like Cobalt Strike for remote control, evading endpoint-based detection of common credential-dumping indicators. However, advanced EDR might still detect via behavioral anomalies (e.g., unusual syscall patterns or LSASS access).
11.2sExpertHow can Grok help?
